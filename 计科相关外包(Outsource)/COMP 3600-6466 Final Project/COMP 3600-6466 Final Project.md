## COMP 3600/6466 Final Project Report

### Milestone - 1: Project Proposal

#### 综述:

本项目将实现 `Which Path to Go?` 程序, 它可以帮助人们找到两点之间的最短可通行路径, 算法将根据1.每条路径上所花费的时间, 2.该路径上是否有房间(结点)达到了最大容量, 导致无法通过. 算法的详细实现方案请看Assumption. 此外它还可以帮助人们在该图上建立费用最小的生成树, 可以为人们提供建立道路连通所有节点的解决方案.

#### **Assumptions:**

+ 房间/地点(节点)之间由路径(边)连通, 其中每条路径具有通行开销(例如通行时间, 通行花费).

+ 房间/地点达到最大容量后, 所有人不能通过该结点.

+ 每个人在出发时有一定的体力值(允许的最大开销), 如果所经过的路径花费的总开销大于此人出发时的开销, 该路径将被标记为非法(不允许这样通行).

+ 在查询最优路径的整个过程中, 区域中的人员数量不会改变. 在结束查询后, 人员数量是动态更新的. 

+ 默认计算开销总不超过`int32`范围, 且每次查询的最优解总是存在的.

+ 输入数据内容/格式包含: 房间/地点的位置信息, 即该房间与那些房间相连, 图结构信息; 每条路径(边, 点到点之间)的通行开销(例如通行时间, 通行花费); 房间/地点(节点)所能容纳的最大人数; 地图上的所有人员及他们的初始位置;

  可执行的查询指令: 在某时刻人员A想要到达地点I的最优路径; 生成全图开销最小的生成树.

#### **Functionalities:**

+ (标记, 将被计算分数的功能1): 该功能覆盖了Topic B.9.: MST+Dijkstra.

  该功能提供生成整个地图关于边开销最小的生成树, 为连通图的最小道路建设开销提供方案. 时间复杂度为 $\mathcal{O} (e \log(v))$, 其中$e$是边集大小, $v$是节点集大小.

+ (标记, 将被计算分数的功能2): 该功能覆盖了Topic B.8.: Dynamic Programming.

  该功能基于图上的生成树进行动态规划, 查找根节点到目的节点的最短路径, 充分利用树结构的无后效性, 树上DP. 时间复杂度为 $\mathcal{O}(e)$

+ (标记, 将被计算分数的功能3): 该功能覆盖了Topic B.4: Heap.

  该功能能快速找到前 $k$ 小开销的点到点路径, 为人们提供更多选择. 时间复杂度为 $\mathcal{O} (k \log(v))$.

+ I/O: 输入数据与查询, 程序建立数据结构并执行算法, 输出当前地图信息与查询结果. 查询可以动态循环多次.

+ 动态更新图的各种信息, 包括节点人数, 通行方案等.

#### M1 反馈

+ 功能 is very vague?

  我们更倾向于建造一个查询路径工具 - 在特定应用场景下, 提供给客户一定的寻路方案, 比如客户希望尽快找到最近的停车场, 这里结点容量对应着停车场内车的数量, 路径上的开销对应着拥堵程度(时间开销), 客户出发时的体力值对应在多少时间内必须到达停车场.

+ 功能2和功能3似乎是相同的?

  并不是, 功能2基于功能1的最小生成树构建, 即需要构建出MST后才能执行, 是近似解(当前MST上的最优解).

  而功能3基于功能1的Dijkstra算法, 不需要最小生成树, 是全局最优解.



### Milestone - 2: Design Document

#### 1 A confirmation and refinement of the software application you will develop. & 2 A confirmation of at least two functionalities you will implement.

我对Milestone1中的三个功能进行确认.

#### 3 The exact algorithm/data structure and Arguments

##### 功能 1 Kruskal MST 详细数据结构说明:

---

数组的实现都是用STL中 `vector` 存储. 输入数据从文件读入, 以下功能已实现, 详细请见代码.

+ 图结构存储: 链式前向星.

  > **链式前向星**是一种用于存储图的数据结构，一般认为是由Jason911发明的。链式前向星采用了邻接表的思想，本质上就是用链表实现的邻接表。可以使用数组模拟链表，定义head,to,nxt,edge数组，其中长度为n的head数组表示从每个节点出发的第一条边在to和edge数组中的位置，长度为m的to和edge是一一对应的，分别记录每条边的终点与边权（对于无权图，edge数组可省略），长度也为m的nxt数组模拟了链表指针，表示从相同节点出发的下一条边在to和edge数组中的位置。因此，链式前向星的空间复杂度为 $\mathcal{O}(n+m)$.
  >
  > 来自中文维基: https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F

  定义数据结构如下:

  ```c++
  struct Edge {
  	int id;
  	int u, v, w;
  	int to, nex;
  };
  
  class Graph {
  public:
  	Graph() { }
  	Graph(string inputFileName = "") {
  		// 读取数据...
  		// 初始化数据结构...
  	}
  	int find(int x) {
  		// 并查集 find 操作...
  	}
  	int n, m;
  	vector<int> fa;
  	vector<Edge> edge;
  
  private:
  	string inputFileName;
  };
  ```

+ Kruskal算法数据结构:

  + 并查集 (自己实现的, 并非调用STL库):

    使用树形结构实现并查集, 初始化时每个结点自成一类, 即对应图中没有任何边连成生成树.

    当有边被加入生成树(例如边 $a, b$ 相连), 则对应并查集的树形数据结构, $a$ 的父亲结点 连接到 $b$ 的父亲结点(并查集的union操作), 请注意这里采用了路径压缩, 即限制每棵树的深度小于2, 这可以大幅提高并查集find操作效率.

  + 结果数组:

    存有当前MST结果.

##### 功能 2 Dijkstra 最短路 详细数据结构说明:

---

使用了 **heap** 数据结构.

+ 以下是**结合堆(数据结构)的Dijkstra的原理**, 详见代码`Dijkstra class` 的实现.

  算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题, 算法最终得到一个最短路径树.
  
  Dijkstra算法采用的是一种贪心的策略, 声明一个数组dst来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合: $T$, 初始时源点 s 的路径权重被赋为 0 (dis[s] = 0).
  
  若对于顶点 s 存在能直接到达的边 (s, m), 则把dst[m]设为 cost(s, m), 同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大. 初始时集合T只有顶点s.
  
  接下来从dst数组选择最小值, 则该值就是源点s到该值对应的顶点的最短路径, 并且把该点加入到T中, 此时完成一个顶点.
  
  我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短, 如果是, 那么就替换这些顶点在dis中的值.
  
  如此往复从dst中找出最小值, 重复上述动作, 直到 $T$ 中包含了图的所有顶点.
  
  如上不断找出数组中的最小值的操作, 我们始终借助 堆 数据结构的结构特性.

##### 功能 3 Heap 找到排名前几的最短路径 详细数据结构说明:

堆(heap)又被为优先队列(priority queue), 在队列中, 我们可以进行的限定操作是dequeue和enqueue. dequeue是按照进入队列的先后顺序来取出元素, 而在堆中, 我们不是按照元素进入队列的先后顺序取出元素的, 而是按照元素的优先级取出元素.

在该问题中优先级就是到该节点路径的开销.

堆的实现

+ 在形式上是完全二叉树(complete binary tree), 这样实现的堆成为二叉堆(binary heap): 完全二叉树是增加了限定条件的二叉树. 假设一个二叉树的深度为n. 为了满足完全二叉树的要求, 该二叉树的前n-1层必须填满, 第n层也必须按照从左到右的顺序被填满.

+ 在物理(代码实现)上是紧密排列的数组, 更新堆代码如下:

  ```python
  void heapify(int n, int i) {
  	int largest = i;
  	int l = 2 * i + 1; // left = 2*i + 1
  	int r = 2 * i + 2; // right = 2*i + 2
  
  	if (l < n && nodeVec[l].cost > nodeVec[largest].cost)
  		largest = l;
  
  	if (r < n && nodeVec[r].cost > nodeVec[largest].cost)
  		largest = r;
  	if (largest != i) {
  		swap(i, largest);
  		heapify(n, largest);
  	}
  }
  ```

#### 类设计说明

![image-20201004202046390](assets/image-20201004202046390.png)



#### 测试用例说明

![image-20201004195909990](assets/image-20201004195909990.png)

如上测试用例, 输入格式为:

```
n, m
x_1, y_1, w_1
接下来m - 1行...

n: 结点数量, m: 边数量.

如上测试用例为:
4 5
2 1 2
1 3 2
4 1 3
3 2 4
3 4 3
```

程序输出: ![image-20201004201127444](assets/image-20201004201127444.png)

+ MST输出以 <id, u, v, weight> 格式.
+ 最短路输出以 4 号结点为源点, 输出到达其他所有节点的最短路.

容易验证程序是正确的.



最佳: 提供平均和最坏情况的推导，讨论最坏情况何时发生。如果最坏情况渐近地比平均情况差，说明在您的应用程序中很少出现最坏情况。如果最坏的情况经常发生，那么就会产生这样的问题:您选择的算法/数据结构是否适合您所遇到的问题。

## 注意:

运行时程序**从 `t.in` 文件中** 标准流形式读入数据, 请按照格式在`t.in`内放置数据.



![image-20201008201422199](assets/image-20201008201422199.png)



# Milestone - 3

2020-11-6 的都在这里, 将本节内容添加到Milestone-2提交的报告中.

添加了一个功能, 也是之前confirm过的.

## Dynamic Programming

DAG图上DP, 该功能适用于在某个交通关系网中, 因为需要控制成本并保证每个节点之间联通, 在所有节点之间建立了一棵树, 即不存在环路, 此时如果我们要寻找两点之间的最短路径, 没有必要使用时间复杂度较高的Dijkstra算法, 在树上可以直接运行动态规划算法寻找最短路.

请注意在巨大的交通网络中, 例如某些供电网络, 建设一条线路的代价是昂贵的, 此时Dijkstra算法只能带来一个最短路的bound(这可以被用于一些启发式搜索策略的函数), DAG图DP算法给出的是实际真实的树上最短距离. 所以该算法与其他功能中的Dijkstra算法不相冲突.

伪代码如下:

```c++
DagShortestPath(G, w, s){
    对节点按照拓扑顺序进行排序
    topologically sort the nodes in G
    初始化:
    for each vertex v in G {
        dist[v] = INF;
        pre[v] = NULL;
    }
    dist[s] = 0;
    根据拓扑顺序, 遍历顶点v
    for each v in G, taken in topologically sorted order {
        for each edge w[u][v] {
            if (dist[v] > dist[u] + w[u][v]){
                pre[v] = dist[u] + w[u][v];
                pre[v] = u;
            }
        }
    }
}
```

在动态规划之前, 我们需要找到一个好的顺序, 在图中即等价为拓扑排序:

在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

1. 每个顶点出现且只出现一次。
2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

进行拓扑排序的步骤为:

从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。

从图中删除该顶点和所有以它为起点的有向边。

重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

这在许多实际应用中同样也是适用的. 比如某些任务之间存在依赖关系, 那么我们可以使用拓扑排序分离出依赖关系.

**时间复杂度分析:**

+ 功能一: Kruskal 最小生成树算法.

  由Kruskal算法过程, 我们有:

  1、初始化生成树的边集A为空集: $\mathcal{O}(1)$

  2、对集合中的每一个顶点，都将它的集合初始化为自身: $\mathcal{O}(V)$.

  4、将边按权值进行排序: 最优为 $\mathcal{O}(E \ log E)$.

  5、对排序好后的边从小到大进行判断：如果这条边所连的2个顶点不在同一个集合中，则将这条边加入到生成树的边集A中，并将此边所连的两个顶点u和v的集合做一个Union操作，如此循环加到生成树中的边集数量为n-1时停止: $\mathcal{O} (V + E) \alpha (V)$, 该步骤算法复杂度的详细证明可以在算法导论并查集那章里面找到.

  所以总时间复杂度为 $\mathcal{O} (E \ logE)$.

  

+ 功能二: Dijkstra 最短路算法.

  请注意我在Dijkstra算法中, 每次extract-min我加入了堆进行优化, 其中 $Q$ 为堆. 首先我们分析没有使用堆优化的时间复杂度:

  总时间复杂度等于找最短距离:

  ```python
  u := vertex in Q with min dist[u]
  ```

  更新距离:

  ```python
  dist[v] := min{dist[v],dist[u] + length(u, v)}
  ```

  以上两者的时间复杂度之和.

  对于一个无向图G(V,E)来说, 最短距离的时间复杂度为$\mathcal{O}(|V| \cdot |V|) $(共循环V次, 每次V个点).

  由于图共有E条边, 每条边最多被更新2次（1条边2个端点）, 因此更新距离的时间复杂度为 $ \mathcal{O}(2 \cdot |E|)$.

  因此, 没有使用堆优化的总时间复杂度为
  $$
  O(2|E|+|V|^2/2)
  $$
  

  接下来, 在引入堆优化后, 我们将集合$Q$转化成一个优先队列(priority queue)，这样findMIN的时间复杂度变成了O(1)，而每次更新priority queue需要花费O(log|V|), 所以使用堆优化(代码实现中的)总时间复杂度为:
  $$
  \mathcal{O}(2|E|+|V|log|V|)
  $$



阶段总结: 以上两个功能已经可以应付大量的实际应用情况, 并且在我设计的算法中, 数据结构都是合适的, 证明如下:

+ 对于边/顶点存在不均衡关系的图中, 因为如上的复杂度分析对边/顶点是不存在分歧的, 所以数据结构总体来说是适用的.
+ 如上已经使用了数据结构有:
  + 堆: 这对于选取集合中的部分最大/最小元素是最优选择.
  + vector: 这对于序列元素的存取和排布是最优选择.
  + Hash表: 这对于<key, value>类型的元素的存取与访问是最优选择, 时间复杂度为 $\mathcal{O}(1)$.

+ 功能三: DAG图动态规划算法.

  在拓扑排序的过程中, 搜索入度为零的顶点所需的时间是 $O(|V|)$. 

  在正常情况下, 每个顶点进一次栈, 出一次栈, 所需时间 $O(|V|)$.

  每个顶点入度减1的运算共执行了$|E|$次, 所以总的时间复杂为 $O(|V| + |E|)$



测试样例说明:

![image-20201106120657017](assets/image-20201106120657017.png)



![image-20201110101244317](assets/image-20201110101244317.png)

+ 堆的时间复杂度分析:

  如上说明, 首先应构建图网络上所需排序/extract max对应的堆, 建堆时间复杂度为 $\mathcal{O} (n)$, 不妨以bottom-up建堆方式为例, 比较元素为关键操作:
  $$
  \begin{aligned}
  &\mathrm{All \ Compare}=\left(\sum_{k=1}^{log(n)} \frac{1}{2^{k}} \times k\right) \mathrm{n}\\
  &Let \ S=\sum_{k=1}^{log(n)} \frac{1}{2^{k}} \times k\\
  &\frac{1}{2} \mathrm{S}=\sum_{k=1}^{l g(n)-1} \frac{1}{2^{k+1}} \times k=\frac{1}{4}+\frac{1}{8} \times 2+\cdots+\frac{1}{2^{k+1}} \times k\\
  &\mathrm{S}-\frac{1}{2} \mathrm{S}=\frac{1}{2} \mathrm{S}=\frac{1}{2}+\frac{1}{4}+\cdots+\frac{1}{2^{k}}-\frac{1}{2^{k+1}} \times k\\
  &\therefore T \leq 2 n \Rightarrow \mathcal{O} (n) .
  \end{aligned}
  $$
  堆取出元素的操作很明显为 $\mathcal{O} (1)$.

  调整堆结构的操作, 由于每次修改仅在其中一条根到叶子结点的路径上, 所以时间复杂度 $\leq \mathcal{O} (logn)$

  综上所述, 堆排序的时间复杂度为 $\mathcal{O} (n \log n)$, 其余使用堆extract max等操作与query次数 $m$ 相关, 为 $\mathcal{O} (m \log n)$.



+ 理论运行时间与实践运行时间的比较:

  我们在每个功能之前添加了测试时间, 在每个功能结束后, 输出该功能的执行时间, 并进行分析:

  不妨以Kruskal算法为例, 分析理论运行时间和实际运行时间的比较, 这里默认采用最大的数据集进行测试.

  如上分析我们知道, Kruskal算法时间复杂度为:
  $$
  \mathcal{O}(V) + \mathcal{O}(E \ log E) (+\mathcal{O} (V + E) \alpha (V))
  $$
  这里不考虑其他操作的通讯开销, 以比较的关键操作为`0.001m`运行为基准, 在数据集大小为`~10e2`情况下, 理论运行时间计算为 `0.764 s`, 实际运行时间为 `0.936`, 基本符合理论分析.

  2. 对于Dijkstra找最短路算法, 由上述分析我们知道, 有向图情形下时间复杂度为:
     $$
     \mathcal{O}(2|E|+|V|log|V|)
     $$
     实际上这里的测试时间应为Kruskal算法的 $\frac{1}{10}$, 因为往往在一个图中顶点数与边的数量相差一个量级, 同样, 我们对于大小为 `~10e2` 的数据集进行测试, 此时顶点大小 `~10e1`, 即理论运行时间计算为: `0.233 s`, 实际运行时间为: `0.391 s`, 基本符合理论分析, 在容忍范围内.

  3. 对于Heap相关的算法, 时间复杂度:
     $$
     \leq \mathcal{O} (n) + \mathcal{O} (logn) + \mathcal{O} (m \log n)
     $$
     理论运行时间为: `0.345 s`, 实际运行时间为: `0.682 s`, 相差较大的原因我们分析为 堆的偏序特性, 使在调整堆的时候交换元素操作开销较大.

  4. 对于Dynamic Programming算法, 时间复杂度为 $\mathcal{O} (n ^c)$ 其中$c$是与算法相关的小常数. 理论运行时间为: `0.064`, 实际运行时间为: `0.050`, 符合预期.

  

  我们测试了大/小数据集上的误差, 发现数据越小 相对误差越大, 可能原因为: 数据集越小时, 关键操作(比较操作)占所有操作(包含通信开销)的比例更小了, 这导致理论分析中没有涵盖的部分更大.



### 关于测试用例:

因为在任务的设计过程中, 每个功能的输入为同一个图, 这样才符合应用场景, 所以对于所有功能的测试用例被放置在 `test-fi-i.txt` 中, 其中 `i` 表示第 `i` 个测试用例, 每个测试用例可以对所有功能测试.